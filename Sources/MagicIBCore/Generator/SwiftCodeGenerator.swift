//
//  SwiftCodeGenerator.swift
//  
//
//  Created by Ryu on 2022/08/21.
//

import Foundation

class SwiftCodeGenerator {
    
    enum IBType {
        case storyboard(ibViewController: IBViewController)
        case xib(ibView: IBView)
    }
    
    let type: IBType
    let url: URL
    
    var fileName: String {
        className + ".swift"
    }
    
    var className: String {
        switch type {
        case .storyboard(_):
            return url
                .deletingPathExtension()
                .lastPathComponent
                .insert(last: "ViewController")
        case .xib(_):
            return url
                .deletingPathExtension()
                .lastPathComponent
        }
    }
    
    private var indentCount = 0
    
    init(url: URL, type: IBType) {
        self.type = type
        self.url = url
    }
    
    func generate() throws -> String {
        switch type {
        case .storyboard(let ibViewController):
            return try generateViewController(ibViewController: ibViewController)
        case .xib(let ibView):
            return generateView(ibView: ibView)
        }
    }
    
}

private extension SwiftCodeGeneratable {
    func buildLines(@ArrayBuilder<Line> _ builder: () -> [Line]) -> [Line] {
        builder()
    }
    
    func generateImport(dependencies: [Dependencies]) -> [Line] {
        Set(dependencies.flatMap { $0.dependencies })
            .sorted()
            .map { Line(relatedVariableName: .import, custom: "import \($0)") }
    }
    
    func generateFileHeader() -> [Line] {
        """
        // \(fileName)
        //
        // This is a generated file.
        // Generated by MagicIB, see https://github.com/Ryu0118/MagicIB
        //
        """.buildLines(relatedVariableName: .fileHeader)
    }
    
    func generateSubviews(parentView: IBView) -> [Line] {
        getAllViews(parentView: parentView)
            .assignName()
            .flatMap { uniqueName, view -> [Line] in
                view.uniqueName = uniqueName
                return view.generateSwiftCode() + [Line.newLine]
            }
    }
    
    func getAllViews(parentView: IBView) -> [Line] {
        return parentView.subviews.findSubviews()
    }
}

//MARK: ViewController extension
private extension SwiftCodeGenerator {
    
    func generateViewController(ibViewController: IBViewController) throws -> String {
        guard let ibView = ibViewController.ibView else { throw "IBViewController property IBView is nil" }
        
        let dependencies: [Dependencies] = [ibViewController.dependencies] + ibViewController.ibView.subviews.compactMap { $0.dependencies }
        let inheritance = ibViewController.superClass.description
        
        return buildLines {
            generateFileHeader()
            Line.newLine
            generateImport(dependencies: dependencies)
            Line.newLine
            Line(variableName: .class, lineType: .declareClass(name: className, inheritances: [inheritance]))
            Line.newLine
            generateSubviews(parentView: ibView)
            generateViewDidLoad()
            Line.newLine
            Line.end
        }
        .calculateIndent()
        .joined(separator: "\n")
    }
    
    func generateViewDidLoad() -> [Line] {
        buildLines {
            Line(function: .init(name: "viewDidLoad", arguments: [], accessLevel: nil, isOverride: true))
            Line(variableName: "super", lineType: .function("super.viewDidLoad()"))
            Line.end
        }
    }
    
}

//MARK: View Extension
private extension SwiftCodeGenerator {
    
    func generateView(ibView: IBView) -> String {
        ""
    }
    
}

private extension Array where Element == Line {
    
    func calculateIndent() -> [String] {
        var indentCount = 0
        return self.map {
            if $0.isStartOfBlock {
                $0.indent(indentCount)
                indentCount += 1
            }
            else if $0.isEndOfBlock {
                indentCount -= 1
                $0.indent(indentCount)
            }
            else {
                $0.indent(indentCount)
            }
            return $0.line
        }
    }
    
}

private extension Array where Element == IBView {
    
    func assignName() -> [(String, IBView)] {
        var classTypeCounts = [IBCompatibleView: Int]()
        return self.map { view -> (String, IBView) in
            if let count = classTypeCounts[view.classType] {
                classTypeCounts.updateValue(count + 1, forKey: view.classType)
            }
            else {
                classTypeCounts.updateValue(0, forKey: view.classType)
            }
            
            guard let count = classTypeCounts[view.classType] else { fatalError() }
            
            if count == 0 {
                return (view.classType.variableName, view)
            }
            else {
                return (view.classType.variableName + "\(count)", view)
            }
        }
    }
    
    func findSubviews() -> [IBView] {
        guard !self.isEmpty else { return self }
        let arrangedSubviews = self
            .compactMap { view -> [IBView] in
                if let stackView = view as? IBStackView {
                    return stackView.arrangedSubviews
                }
                else {
                    return view.subviews
                }
            }
            .flatMap { $0 }
        return self + arrangedSubviews.findSubviews()
    }
    
}
